<!DOCTYPE html>
<html>

<head>
	<title>Profile Page</title>
	<style>
		table, th, td {
		  border:1px solid black;
		}
	</style>
</head>

<body>
	<a href="bonus.html">Bonus Page</a>
	<h1>Nikhil Nagabandi</h1>
	<h6>Taj Mahal</h6>
	<p>
		I like <strong>Taj Mahal</strong> very much it is one of the most beautiful place in the world and also it is
		one the top <strong>Tourist place</strong> around the world.
	</p>
	<h3>Travel Info from Maryville to TajMahal</h3>
	<hr>
	<ol>
		<li>
			First we should book a Fight ticket from the travel booking website from Kansas to Chicago and Chicago to
			Delhi.
			<ol>
				<li>Book a cab OR RENT a car and take a ride from Maryville to Kansas city airport(MCI)
					<ol>
						<li>
							Once reached to Kansas city airport(MCI) take the boarding pass from the counter.
						</li>
						<li>
							Then travel to chicago from kansas in flight.
						</li>
					</ol>
				</li>
			</ol>
		</li>
		<li>
			After boarding the flight in chicago then go ahead and change the terminal from domestic to international.
			<ol>
				<li>
					once arrived in chicago international airport(ORD) take the boarding pass from the counter.
				</li>
				<li>
					Then travel to Delhi from chicago in flight.
				</li>
			</ol>
		</li>
	</ol>
	<ul>
		<li>
			After boarding the flight in Delhi international airport then go ahead and take the book a cab or Rent a car
			from Delhi airport to Taj mahal.
		</li>
		<ul>
			<li>
				If we book a cab then Cab driver will take you to Taj mahal directly based on the maps directions.
			</li>
			<li>
				If we rent a cab then go ahead and take a ride till Taj mahal it take 3hrs 30mins to reach the
				destination.
				<ul>
					<li>
						The easiest & cheapest way to go to Taj Mahal is via Agra One Volvo Bus one day trip
					</li>
				</ul>
			</li>
			<li>
				To board the bus simply take a Taxi from the Airport to pick up point at INA Metro Station Gate No.
			</li>
		</ul>
	</ul>
	<ul>
		<li>
			Here you go once reached there you can an awesome view of Taj Mahal.
			<ul>
				<li>
					Once you reach there you can find and amazing food.
					<ul>
						<li>Biryani</li>
						<li>Masala Dosa</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	<p><a href="aboutme.html">About My Superhero</a></p>
	<h3>Famous Foods in Bangalore</h3>
	<hr>
	<p>The following table consists some of most famous foods that are available in Bangalore.</p>
	<table style="width:50%">
		<tr>
			<th>Food Item</th>
			<th>Loaction</th>
			<th>Price</th>
		</tr>
		<tr>
			<td>Chicken Biryani</td>
			<td>Krutinga</td>
			<td>$8</td>
		</tr>
		<tr>
			<td>Masala Dosa</td>
			<td>Vidyarthi Bhavan</td>
			<td>$5</td>
		</tr>
		<tr>
			<td>Mand house</td>
			<td>Arabian Mandi</td>
			<td>$15</td>
		</tr>
		<tr>
			<td>Hard Rock Cafe</td>
			<td>Coffie</td>
			<td>$6</td>
		</tr>
	</table>
	<h3>Code Fencing</h3>
	<hr>
	<blockquote>
		The Pólya enumeration theorem, also known as the Redfield–Pólya theorem and Pólya counting, is a theorem in combinatorics that both follows from and ultimately generalizes Burnside's lemma on the number of orbits of a group action on a set. The theorem was first published by J. Howard Redfield in 1927.<a href="https://en.wikipedia.org/wiki/P%C3%B3lya_enumeration_theorem">Click here to know more about the Pólya enumeration theorem</a>
	</blockquote>
	<pre>
		using Permutation = vector<int>;

			void operator*=(Permutation& p, Permutation const& q) {
				Permutation copy = p;
				for (int i = 0; i < p.size(); i++)
					p[i] = copy[q[i]];
			}
			
			int count_cycles(Permutation p) {
				int cnt = 0;
				for (int i = 0; i < p.size(); i++) {
					if (p[i] != -1) {
						cnt++;
						for (int j = i; p[j] != -1;) {
							int next = p[j];
							p[j] = -1;
							j = next;
						}
					}
				}
				return cnt;
			}
			
			int solve(int n, int m) {
				Permutation p(n*m), p1(n*m), p2(n*m), p3(n*m);
				for (int i = 0; i < n*m; i++) {
					p[i] = i;
					p1[i] = (i % n + 1) % n + i / n * n;
					p2[i] = (i / n + 1) % m * n + i % n;
					p3[i] = (m - 1 - i / n) * n + (n - 1 - i % n);
				}
			
				set<Permutation> s;
				for (int i1 = 0; i1 < n; i1++) {
					for (int i2 = 0; i2 < m; i2++) {
						for (int i3 = 0; i3 < 2; i3++) {
							s.insert(p);
							p *= p3;
						}
						p *= p2;
					}
					p *= p1;
				}
			
				int sum = 0;
				for (Permutation const& p : s) {
					sum += 1 << count_cycles(p);
				}
				return sum / s.size();
			}
	</pre>
	<a href="https://cp-algorithms.com/combinatorics/burnside.html">click here to view the cp-algorithms</a>
</body>

</html>